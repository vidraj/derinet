package Treex::Tool::DerivMorpho::Block::CS::ExtractCandidatesForUnexploitedRules;
use Moose;
use Treex::Tool::DerivMorpho::Block;
extends 'Treex::Tool::DerivMorpho::Block';

use Treex::Core::Log;


sub process_dictionary {

    my ($self, $dict) = @_;
    open my $R, '<:utf8', $self->my_directory.'manual.AddManuallyConfirmedAutorules.rules.tsv' or die $!;
    my $number_of_rules;

    my %rules;

    while (<$R>) {

        my $already_confirmed_rule = 0;
        if (/^\$/) { # rules already annotated as invalid
            next;
        }
        elsif (s/^\*//) { # already confirmed, but some instances might have been missed because of error in regexp
            $already_confirmed_rule = 1;
        }

        $number_of_rules++;
        last if $number_of_rules > 250;

        s/^\s*\d+\s//;
        if (/^([ADVN])-(\w*) ([ADVN])-(\w*)/) {
            my ($source_pos,$source_suffix,$target_pos,$target_suffix) = ($1,$2,$3,$4);
            next if $source_suffix eq "" and $target_suffix eq "";
            $rules{$target_suffix}{$target_pos}{$source_suffix}{$source_pos} = 1 + $already_confirmed_rule;
        }
        else {
            log_warn("Warning: Unparsable line: $_");
        }
    }


    my $number;

  TARGET:
    foreach my $target_lexeme ($dict->get_lexemes) {
        $number++;
#        print "Processing $number th lexeme\n";

        next TARGET if $target_lexeme->source_lexeme;

        my $target_lemma = $target_lexeme->lemma;

#        print "X0: $target_lemma\n";

        foreach my $len (reverse(0..3)) { # nebo od nejkratsich?
#                print "  X2: length $len\n";
            if ($target_lemma =~ /^(.+)(.{$len})$/) {
#                    print "    X3\n";
                my ($target_stem,$target_suffix) = ($1,$2);
                if ($rules{$target_suffix}{$target_lexeme->pos}) {
#                        print "      X4\n";

                  SUFFIX:
                    foreach my $source_suffix (keys %{$rules{$target_suffix}{$target_lexeme->pos}}) {
                        my $source_lemma = $target_lemma;

                        $source_lemma =~ s/$target_suffix$/$source_suffix/ or log_fatal("the rule can't be applied - this should never happen");

#                        print "        X5: '$target_suffix' --> '$source_suffix'         guessed lemma = $source_lemma\n";

                        foreach my $source_lexeme ($dict->get_lexemes_by_lemma($source_lemma)) {
#                                print "          X6\n";
                          POS:
                            foreach my $source_pos (%{$rules{$target_suffix}{$target_lexeme->pos}{$source_suffix}}) {
#                                                            print "            X7\n";
                                if ($source_lexeme->pos eq $source_pos) {

                                    my $marker_of_bug_fix = "";
                                    if ($rules{$target_suffix}{$target_lexeme->pos}{$source_suffix}{$source_pos} > 1) {

                                        if (not $target_lemma =~ /$target_suffix./) { # compensating the old bug (missing /...$/)
                                            next POS;
                                        }
                                        else {
#                                            $marker_of_bug_fix = "QQQ";
                                        }
                                    }


                                    print "${marker_of_bug_fix}novy par: $source_lemma --> $target_lemma\t pravidlo: $source_pos-$source_suffix --> ".$target_lexeme->pos."-$target_suffix\n";

                                    $dict->add_derivation({
                                        source_lexeme => $source_lexeme,
                                        derived_lexeme => $target_lexeme,
                                        deriv_type => $source_lexeme->pos."2".$target_lexeme->pos,
                                    });
                                    next TARGET;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return $dict;

}
